分布式事务基础理论：cap

~~~
c: consistency 一致性
a: availability 可用性
p: partition-tolerance 分区容错性
ap 放弃一致性，例如：数据可以N+1 展示 
cp 放弃可用性，zookeeper 就是强一致性，比如：跨行转账，一次转账需要双方银行系统都完成事务才算完成。
ca 放弃分区容错性，即使不分区，不考虑网络挂掉或者不通的场景
总结：一个分布式系统最多满足三项中的两个条件，进行架构设计，技术考量的标准。对于多应用场景，结点多，部署分散，一般情况下保证P与A ，保证最终一致性
~~~

理解强一致性和最终一致性

  Base理论介绍

  ~~~
BASE 是 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩。
BASE理论是对CAP中AP的一个扩展，通过牺牲强一致性来获得可用性，当出现故障允许部分不可用但要保证
核心功能可用，允许数据在一段时间内是不一致的，但最终达到一致状态。满足BASE理论的事务，我们称之为“柔
性事务
基本可用:分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。如，电商网站交易付款出
现问题了，商品依然可以正常浏览。
软状态:由于不要求强一致性，所以BASE允许系统中存在中间状态（也叫软状态），这个状态不影响系统可用
性，如订单的"支付中"、“数据同步中”等状态，待数据最终一致后状态改为“成功”状态。
最终一致:最终一致是指经过一段时间后，所有节点数据都将会达到一致。如订单的"支付中"状态，最终会变
为“支付成功”或者"支付失败"，使订单状态与实际交易结果达成一致，但需要一定时间的延迟、等待
  ~~~

分布式事务的解决方案：

1， 分布式事务解决方案之2PC(两阶段提交)

~~~
2pc提交协议，指两阶段提交，准备阶段（prepare phase）,提交阶段（commit phase）,整个事务由管理器与参与者组成，事务管理负责决策分布式事务的提前与回滚，参与者决策本地事务的提交回滚。
~~~

  解决方案：

~~~
一、XA方案：
   按国际化开放组织Open Group定义了分布式事务模型DTP（Distributed Transaction Processing Reference Model）这个场景只适合几毫秒，几分钟就能处理的sql脚本
   DTP模型定义如下角色：AP（应用程序）,RM（资源管理器）,TM（事务管理器）,TM和RM之间通讯的接口规范叫XA
二、seata方案：它目前提供AT模式(即2PC)及TCC模式的分布式事务解决方案
   过对本地关系数据库的分支事务的协调来驱动完成全局事务，是工作在应用层的中间件.
   Seata定义了3个组件来协议分布式事务的处理过程
   TC(Transaction Coordinator)： 事务协调器，它是独立的中间件
   Transaction Manager (TM)： 事务管理器，
   Resource Manager (RM)： 控制分支事务，
~~~



2，分布式事务解决方案之TCC

~~~
TCC try confirm cancel 三个词的缩写，
 try:预算处理，业务检查预留，
 confirm:确认，做业务确认操作
 cancel：撤销 ，执行一个try相反的操作回滚
 TM事务管理器TM事务管理器可以实现为独立的服务，也可以让全局事务发起方充当TM的角色，TM独立出来是为了成为公用组件，是为了考虑系统结构和软件复用
~~~

 解决方案：

~~~
框架名称 Gitbub地址 star数量
tcc-transaction https://github.com/changmingxie/tcc-transaction 3850
Hmily 			https://github.com/yu199195/hmily 2407
ByteTCC 		https://github.com/liuyangming/ByteTCC 1947
EasyTransaction https://github.com/QNJR-GROUP/EasyTransaction 1690
总结：这些都是网上常用的解决管理方案：TCC事务的处理流程与2PC两阶段提交做比较，2PC通常都是在跨库的DB层面，而TCC则在应用层面的处理，需要通过业务逻辑实现，
优势：可以让应用自己定义数据操作粒度，使得降低冲突，提高吞吐量成为可能
缺点：应用侵入非常强，业务逻辑都需要三个阶段操作，开发难度大，需要按网络状态，系统故障等不同的失败原因进行不同的失败策略进行回滚。
~~~



3，分布式事务解决方案之可靠消息最终一致性

~~~
本地事务与消息发送的原子性问题：事务本地发事务执行成功后消息发出，否则就消息丢失，即实现本地事务和消息发送的原子性，要么都成功，要么都失败
RocketMQ实现可靠消息最终一致性事务
总结：可靠消息最终一致性就是保证消息从生产方经过消息中间件传递到消费方的一致性，本案例使用了RocketMQ作为
消息中间件，RocketMQ主要解决了两个功能：
1、本地事务与消息发送的原子性问题。
2、事务参与方接收消息的可靠性。
可靠消息最终一致性事务适合执行周期长且实时性要求不高的场景。引入消息机制后，同步的事务操作变为基于消
息执行的异步操作, 避免了分布式事务中的同步阻塞操作的影响，并实现了两个服务的解耦
~~~



4，分布式事务解决方案之最大努力通知

~~~
通过对最大努力通知的理解，采用MQ的ack机制就可以实现最大努力通知。
最大努力通知方案是分布式事务中对一致性要求最低的一种,适用于一些最终一致性时间敏感度低的业务；
最大努力通知方案需要实现如下功能：
1、消息重复通知机制。
2、消息校对机制。
~~~



5，分布式事务综合案例分析

~~~

~~~











