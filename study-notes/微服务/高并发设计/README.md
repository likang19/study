https://www.yuque.com/jdxj/lliyz8/uai9i7

01：高并发系统常用设计方法：（3种）

~~~
1.分离流量：横向扩展，采用分布式的部署的方式，让流量分开，让每台服务器承担一部分流量
2.缓存：使用缓存来提高系统性能
3.异步：未处理完成之前的我们可以请求返回，在数据准备好后在去通知对方	
~~~

02：架构分层：

   ~~~
  mvc ,mvvc,OSI网络模型，TCP/IP,linux 都是做了分层
  分层的好处：复杂的系统拆分开，不同的人做不同的事，分层后可以做到高可用，分层架构可以让我们更好的做横向扩展
  分层的缺点：增加代码的复杂度，每层都独立部署，在性能上有损耗 

   ~~~

03：高并发设计目标：高性能，高可用，可扩展

​	03-1：系统怎么样做到高可用

~~~
可用性是一个抽像概念，如何来度量它MTBF和MTTR
MTBF：是平均故障间隔的意思
MTTR：表示故障的平台恢复时间
Availability = MTBF / (MTBF + MTTR)
~~~

​      03-2：系统怎么样做到可扩展

~~~
高可扩展是一个设计指标，可能是增加机器的方式来线性的提高机器的处理能力，从而承担更高的流量和并发
提高扩展性很复杂：
   无状态的服务组件易扩展，有状态的扩展比较难，比如mysql 就是有状态，因为向存储集群中增加或者减少机器时，会涉及大量的数据迁移。一搬的关系性数据库都不支持，
高扩展思路：
   服务层拆分->将一个大系统某个子项拆分出来独立，有单一职责模板，复杂的问题简单化，
   存储层扩展->存储拆分首先考虑的维度是业务维度,拆分之后，这个简单的社区系统就有了用户库、内容库、评论库、点赞库和关系库。这么做还能隔离故障，某一个库“挂了”不会影响到其它的数据库
   业务层扩展性->一般从三个维度考虑业务层的拆分方案，它们分别是：业务维度，重要性维度和请求来源维度	
~~~

04：池化技术，

05：查询请求增加，可做主从分离

06：写数据增加，主从拆分

07：发信号器：保证分库分表后的全局唯一ID

~~~
雪花算法： 时间戳、机器 ID、序列号等等，
缺点：依赖于系统的时间戳，如果请求发号器的 QPS 不高，比如说发号器每毫秒只发一个 ID，就会造成生成 ID 的末位永远是 1，那么在分库分表时如果使用 ID 作为分区键就会造成库表分配的不均匀
	
~~~

08：缓存：

~~~
数据库成为瓶颈后，动态查询加速：旁路缓存：会有同步问题，不一致问题
缓存如何做到高可用：分片（hash分片） Memcached 的主从机制，多副本，中间代理层方案
缓存穿透了怎么办：回种空值，布隆过滤器
~~~

09：RPC框架：10万QPS下如何实现毫秒级的服务调用？

~~~
● RMI 使用专为 Java 远程对象定制的协议 JRMP（Java Remote Messaging Protocol）进行通信，这限制了它的通信双方只能是 Java 语言的程序，无法实现跨语言通信；
● RMI 使用 Java 原生的对象序列化方式，生成的字节数组空间较大，效率很差。
RPC调用过程：
	1.要先把类，方法，参数名，值等先序列化成二进制流
	2.然后客户端将二进制流传输给服务端
	3.服务端收到二进制流后返序列化，得到所需的类，方法，参数，值
	4.服务端将返序列化，在通过网络给客户端
	5.客户端返序列化，就可以得到结果
总结：序列化很重要：合适的序列化方式
~~~

10：注册中心：分布式是如何寻址？

~~~
 ZooKeeper、Kubernetes 使用的 ETCD、阿里的微服务注册中心 Nacos、Spring Cloud 的 Eureka 等等。
 心跳模式: zk,eureka按照一定的时间间隔（比如 30 秒），向注册中心发送心跳包。注册中心在接收到心跳包之后，会更新这个节点的最近续约时间
~~~

11:分布式Trace：横跨几十个分布式组件的慢请求要如何排查？

~~~
采用 traceId + spanId 这两个数据维度来记录服务之间的调用关系（这里 traceId 就是 requestId），也就是使用 traceId 串起单次请求，用 spanId 记录每一次 RPC 调用。
~~~

12:流量控制：高并发系统中我们如何操纵流量？

~~~
窗口流量，滑动窗口算法，固定窗口算法
~~~

13：计数系统设计（一）：面对海量数据的计数器要如何做？

~~~
1.开始使用简单方案
2.量达到千万时，分库分表，用户Id做分区键	
3.计数器访问量级上升：使用redis 加速读请求，提升写的性能，使用消息队列
4.降低计数系统的存储成本：Key 是 8 字节 Long 类型的 weibo_id，Value 是 4 字节 int 类型的转发数，存储在 Redis 中之后会占用超过 70 个字节的空间
~~~

14：未读系统设计：50万QPS

~~~
通过计算，不是统计，
1.通过存储Id上加计算统计，取最后一条数据
2.通过缓存重置未读数
~~~

15：扩容-数据库

~~~
读操作扩容：memcache 、redis ,cdn等缓存操作
写操作扩容：cassandra ,hbase等缓存
~~~



