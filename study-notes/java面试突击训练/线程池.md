#### **1. 面试官：日常工作中有用到线程池吗？什么是线程池？为什么要使用线程池？**

![输入图片说明](images/threadPool_20220912142224.jpg"QQ截图20201229183512.png")



**使用线程池可以带来以下好处：**

  ~~~
1.降低资源消耗，降低频繁创建，销毁线程池带来的额外开销，复用已有线程
2.降低使用复杂度，将任务的提交和执行进行解耦，我们只需要创建一个线程池，然后往里面提交任务就行，具体执行3.流程由线程池自己管理，降低使用复杂度
4.提高线程可管理性。能安全有效的管理线程资源，避免不加限制无限申请造成资源耗尽风险
5.提高响应速度。任务到达后，直接复用已创建好的线程执行
  ~~~

**线程池的使用场景简单来说可以有：**
1. **快速响应用户请求，响应速度优先**。比如一个用户请求，需要通过 RPC 调用好几个服务去获取数据然后聚合返回，此场景就可以用线程池并行调用，响应时间取决于响应最慢的那个 RPC 接口的耗时；又或者一个注册请求，注册完之后要发送短信、邮件通知，为了快速返回给用户，可以将该通知操作丢到线程池里异步去执行，然后直接返回客户端成功，提高用户体验。
2. **单位时间处理更多请求，吞吐量优先**。比如接受 MQ 消息，然后去调用第三方接口查询数据，此场景并不追求快速响应，主要利用有限的资源在单位时间内尽可能多的处理任务，可以利用队列进行任务的缓冲

#### **2. 面试官：ThreadPoolExecutor 都有哪些核心参数？**

1. 判断线程池的状态，如果不是RUNNING状态，直接执行拒绝策略

2. 如果当前线程数 < 核心线程池，则新建一个线程来处理提交的任务

3. 如果当前线程数 > 核心线程数且任务队列没满，则将任务放入阻塞队列等待执行

4. 如果 核心线程池 < 当前线程池数 < 最大线程数，且任务队列已满，则创建新的线程执行提交的任务

5. 如果当前线程数 > 最大线程数，且队列已满，则执行拒绝策略拒绝该任务

   ![输入图片说明](images/微信截图_20220912142804.png"QQ截图20201229183512.png")

他们提供了阻塞队列 TaskQueue，该队列继承 LinkedBlockingQueue，重写了 offer() 方法来实现执行流程的调整。

~~~
1.如果 parent 为 null，直接调用父类 offer 方法入队
2.如果当前线程数等于最大线程数，则直接调用父类 offer()方法入队
3.如果当前未执行的任务数量小于等于当前线程数，仔细思考下，是不是说明有空闲的线程呢，那么直接调用父类 offer() 入队后就马上有线程去执行它
4.如果当前线程数小于最大线程数量，则直接返回 false，然后回到 JUC 线程池的执行流程回想下，是不是就去添加新线程去执行任务了呢
5.其他情况都直接入队
~~~

#### **3. 面试官：什么是阻塞队列？说说常用的阻塞队列有哪些？**

​	阻塞队列 BlockingQueue 继承 Queue 当从阻塞队列中获取数据时，如果队列为空，则等待直到队列有元素存入。当向阻塞队列中存入元素时，如果队列已满，则等待直到队列中有元素被移除。提供 offer()、put()、take()、poll() 等常用方法。

**JDK 提供的阻塞队列的实现有以下几种：**

ArrayBlockingQueue,LinkedBlockingQueue,SynchronousQueue,PriorityBlockingQueue,DelayQueue,LinkedTransferQueue

#### **4. 面试官：你刚说到了 Worker 继承 AQS 实现了锁机制，那 ThreadPoolExecutor 都用到了哪些锁？为什么要用锁？**

1) mainLock 锁 在访问 workers 成员变量以及进行相关数据统计记账（比如访问 largestPoolSize、completedTaskCount）时需要获取该重入锁。

2）Worker 线程锁 刚也说了 Worker 线程继承 AQS，实现了 Runnable 接口，内部持有一个 Thread 变量，一个 firstTask，及 completedTasks 三个成员变量。

基于 AQS 的 acquire()、tryAcquire() 实现了 lock()、tryLock() 方法，类上也有注释，该锁主要是用来维护运行中线程的中断状态。在 runWorker() 方法中以及刚说的 interruptIdleWorkers() 方法中用到了。

#### **5. 面试官：你在项目中是怎样使用线程池的？Executors 了解吗？**

阿里巴巴 Java 开发规范，该规范里明确说明不允许使用 Executors 创建线程池，而是通过 ThreadPoolExecutor 显示指定参数去创建, Executors 创建的线程池有发生 OOM 的风险。

#### **6. 面试官：刚你说到了通过 ThreadPoolExecutor 来创建线程池，那核心参数设置多少合适呢？**

**其实没有固定答案，需要通过压测不断的动态调整线程池参数，观察 CPU 利用率、系统负载、GC、内存、RT、吞吐量 等各种综合指标数据，来找到一个相对比较合理的值。**

**所以不要再问设置多少线程合适了，这个问题没有标准答案，需要结合业务场景，设置一系列数据指标，排除可能的干扰因素，注意链路依赖（比如连接池限制、三方接口限流），然后通过不断动态调整线程数，测试找到一个相对合适的值。**

#### **7. 面试官：你们线程池是咋监控的？**

我们自己对线程池 ThreadPoolExecutor 做了一些增强，做了一个线程池管理框架。主要功能有监控告警、动态调参。主要利用了 ThreadPoolExecutor 类提供的一些 set、get方法以及一些钩子函数。

动态调参是基于配置中心实现的，核心参数配置在配置中心，可以随时调整、实时生效，利用了线程池提供的 set 方法。监控，主要就是利用线程池提供的一些 get 方法来获取一些指标数据，然后采集数据上报到监控系统进行大盘展示。也提供了 Endpoint 实时查看线程池指标数据。

同时定义了5种告警规则。

~~~
线程池活跃度告警。活跃度 = activeCount / maximumPoolSize，当活跃度达到配置的阈值时，会进行事前告警。
队列容量告警。容量使用率 = queueSize / queueCapacity，当队列容量达到配置的阈值时，会进行事前告警。
拒绝策略告警。当触发拒绝策略时，会进行告警。
任务执行超时告警。重写 ThreadPoolExecutor 的 afterExecute() 和 beforeExecute()，根据当前时间和开始时间的差值算出任务执行时长，超过配置的阈值会触发告警。
任务排队超时告警。重写 ThreadPoolExecutor 的  beforeExecute()，记录提交任务时时间，根据当前时间和提交时间的差值算出任务排队时长，超过配置的阈值会触发告警
~~~

通过监控+告警可以让我们及时感知到我们业务线程池的执行负载情况，第一时间做出调整，防止事故的发生。

#### **8. 面试官：你在使用线程池的过程中遇到过哪些坑或者需要注意的地方？**

1）OOM 问题。刚开始使用线程都是通过 Executors 创建的，前面说了，这种方式创建的线程池会有发生 OOM 的风险。

2）任务执行异常丢失问题。可以通过下述4种方式解决
~~~
  在任务代码中增加 try、catch 异常处理
  如果使用的 Future 方式，则可通过 Future 对象的 get 方法接收抛出的异常
  为工作线程设置 setUncaughtExceptionHandler，在 uncaughtException 方法中处理异常
  可以重写 afterExecute(Runnable r, Throwable t) 方法，拿到异常 t
~~~
3）共享线程池问题。整个服务共享一个全局线程池，导致任务相互影响，耗时长的任务占满资源，短耗时任务得不到执行。同时父子线程间会导致死锁的发生，今儿导致 OOM

4）跟 ThreadLocal 配合使用，导致脏数据问题。我们知道 Tomcat 利用线程池来处理收到的请求，会复用线程，如果我们代码中用到了 ThreadLocal，在请求处理完后没有去 remove，那每个请求就有可能获取到之前请求遗留的脏值。

5）ThreadLocal 在线程池场景下会失效，可以考虑用阿里开源的 Ttl 来解决



**以上提到的线程池动态调参、通知告警在开源动态线程池项目 DynamicTp 中已经实现了，可以直接引入到自己项目中使用。**

DynamicTp 是一个基于配置中心实现的轻量级动态线程池管理工具，主要功能可以总结为动态调参、通知报警、运行监控、三方包线程池管理等几大类。

https://dynamictp.cn/

https://gitee.com/dromara/dynamic-tp